#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 10 16
    bytecblock "ft" "current_num_tiers" "admin_account" "flux_record" 0x0000000000000000
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txn NumAppArgs
    bz main_after_if_else@12
    pushbytess 0xda53fefe 0xf927a9f6 0x5b47b18e 0x6c8a0318 0xa07d00cf 0xd4d7aa5c // method "createApplication(account)void", method "initApplication(pay)void", method "addFluxTier(uint64,uint64)void", method "removeFluxTier(uint64)void", method "setUserTier(address,uint64)void", method "getUserTier(address)uint64"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_initApplication_route@4 main_addFluxTier_route@5 main_removeFluxTier_route@6 main_setUserTier_route@7 main_getUserTier_route@8

main_after_if_else@12:
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    intc_1 // 0
    return

main_getUserTier_route@8:
    // smart_contracts/flux_gate/flux-gate.algo.ts:73
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/flux_gate/flux-gate.algo.ts:73
    // @abimethod({ allowActions: "NoOp" })
    callsub getUserTier
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_setUserTier_route@7:
    // smart_contracts/flux_gate/flux-gate.algo.ts:63
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/flux_gate/flux-gate.algo.ts:63
    // @abimethod({ allowActions: "NoOp" })
    callsub setUserTier
    intc_0 // 1
    return

main_removeFluxTier_route@6:
    // smart_contracts/flux_gate/flux-gate.algo.ts:54
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/flux_gate/flux-gate.algo.ts:54
    // @abimethod({ allowActions: "NoOp" })
    callsub removeFluxTier
    intc_0 // 1
    return

main_addFluxTier_route@5:
    // smart_contracts/flux_gate/flux-gate.algo.ts:45
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/flux_gate/flux-gate.algo.ts:45
    // @abimethod({ allowActions: "NoOp" })
    callsub addFluxTier
    intc_0 // 1
    return

main_initApplication_route@4:
    // smart_contracts/flux_gate/flux-gate.algo.ts:38
    // @abimethod({ allowActions: "NoOp" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/flux_gate/flux-gate.algo.ts:38
    // @abimethod({ allowActions: "NoOp" })
    callsub initApplication
    intc_0 // 1
    return

main_createApplication_route@3:
    // smart_contracts/flux_gate/flux-gate.algo.ts:33
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/flux_gate/flux-gate.algo.ts:20-21
    // @contract({ name: "flux-gate", avmVersion: 11 })
    // export class FluxGate extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/flux_gate/flux-gate.algo.ts:33
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    callsub createApplication
    intc_0 // 1
    return


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.createApplication(admin: bytes) -> void:
createApplication:
    // smart_contracts/flux_gate/flux-gate.algo.ts:33-34
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    // public createApplication(admin: Account): void {
    proto 1 0
    // smart_contracts/flux_gate/flux-gate.algo.ts:23
    // admin_account = GlobalState<Account>();
    bytec_2 // "admin_account"
    // smart_contracts/flux_gate/flux-gate.algo.ts:35
    // this.admin_account.value = admin;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.initApplication(mbrTxn: uint64) -> void:
initApplication:
    // smart_contracts/flux_gate/flux-gate.algo.ts:38-39
    // @abimethod({ allowActions: "NoOp" })
    // public initApplication(mbrTxn: gtxn.PaymentTxn): void {
    proto 1 0
    // smart_contracts/flux_gate/flux-gate.algo.ts:40
    // assertMatch(mbrTxn, { receiver: Global.currentApplicationAddress, amount: 400_000 });
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    bz initApplication_bool_false@3
    frame_dig -1
    gtxns Amount
    pushint 400000 // 400000
    ==
    bz initApplication_bool_false@3
    intc_0 // 1

initApplication_bool_merge@4:
    // smart_contracts/flux_gate/flux-gate.algo.ts:40
    // assertMatch(mbrTxn, { receiver: Global.currentApplicationAddress, amount: 400_000 });
    assert // assert target is match for conditions
    // smart_contracts/flux_gate/flux-gate.algo.ts:27
    // flux_tiers = Box<StaticArray<FluxTier, 10>>({ key: "ft" });
    bytec_0 // "ft"
    // smart_contracts/flux_gate/flux-gate.algo.ts:41
    // this.flux_tiers.create();
    pushint 160 // 160
    box_create
    pop
    // smart_contracts/flux_gate/flux-gate.algo.ts:29
    // current_num_tiers = GlobalState<uint64>();
    bytec_1 // "current_num_tiers"
    // smart_contracts/flux_gate/flux-gate.algo.ts:42
    // this.current_num_tiers.value = 0;
    intc_1 // 0
    app_global_put
    retsub

initApplication_bool_false@3:
    intc_1 // 0
    b initApplication_bool_merge@4


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.addFluxTier(tierNumber: uint64, minRequired: bytes) -> void:
addFluxTier:
    // smart_contracts/flux_gate/flux-gate.algo.ts:45-46
    // @abimethod({ allowActions: "NoOp" })
    // public addFluxTier(tierNumber: uint64, minRequired: UintN64): void {
    proto 2 0
    // smart_contracts/flux_gate/flux-gate.algo.ts:48
    // assert(op.Txn.sender === this.admin_account.value);
    txn Sender
    // smart_contracts/flux_gate/flux-gate.algo.ts:23
    // admin_account = GlobalState<Account>();
    intc_1 // 0
    bytec_2 // "admin_account"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/flux_gate/flux-gate.algo.ts:48
    // assert(op.Txn.sender === this.admin_account.value);
    ==
    assert
    // smart_contracts/flux_gate/flux-gate.algo.ts:50
    // const newTier = new FluxTier({ tierNumber: new UintN64(tierNumber), minRequired });
    frame_dig -2
    itob
    frame_dig -1
    concat
    // smart_contracts/flux_gate/flux-gate.algo.ts:27
    // flux_tiers = Box<StaticArray<FluxTier, 10>>({ key: "ft" });
    bytec_0 // "ft"
    // smart_contracts/flux_gate/flux-gate.algo.ts:51
    // this.flux_tiers.value[tierNumber] = newTier.copy();
    box_get
    assert // Box must have value
    frame_dig -2
    intc_2 // 10
    <
    assert // Index access is out of bounds
    frame_dig -2
    intc_3 // 16
    *
    uncover 2
    replace3
    // smart_contracts/flux_gate/flux-gate.algo.ts:27
    // flux_tiers = Box<StaticArray<FluxTier, 10>>({ key: "ft" });
    bytec_0 // "ft"
    // smart_contracts/flux_gate/flux-gate.algo.ts:51
    // this.flux_tiers.value[tierNumber] = newTier.copy();
    swap
    box_put
    // smart_contracts/flux_gate/flux-gate.algo.ts:29
    // current_num_tiers = GlobalState<uint64>();
    intc_1 // 0
    bytec_1 // "current_num_tiers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/flux_gate/flux-gate.algo.ts:52
    // this.current_num_tiers.value += 1;
    intc_0 // 1
    +
    // smart_contracts/flux_gate/flux-gate.algo.ts:29
    // current_num_tiers = GlobalState<uint64>();
    bytec_1 // "current_num_tiers"
    // smart_contracts/flux_gate/flux-gate.algo.ts:52
    // this.current_num_tiers.value += 1;
    swap
    app_global_put
    retsub


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.removeFluxTier(tierNumber: uint64) -> void:
removeFluxTier:
    // smart_contracts/flux_gate/flux-gate.algo.ts:54-55
    // @abimethod({ allowActions: "NoOp" })
    // removeFluxTier(tierNumber: uint64): void {
    proto 1 0
    // smart_contracts/flux_gate/flux-gate.algo.ts:57
    // assert(op.Txn.sender === this.admin_account.value);
    txn Sender
    // smart_contracts/flux_gate/flux-gate.algo.ts:23
    // admin_account = GlobalState<Account>();
    intc_1 // 0
    bytec_2 // "admin_account"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/flux_gate/flux-gate.algo.ts:57
    // assert(op.Txn.sender === this.admin_account.value);
    ==
    assert
    // smart_contracts/flux_gate/flux-gate.algo.ts:27
    // flux_tiers = Box<StaticArray<FluxTier, 10>>({ key: "ft" });
    bytec_0 // "ft"
    // smart_contracts/flux_gate/flux-gate.algo.ts:59
    // this.flux_tiers.value[tierNumber] = new FluxTier({ tierNumber: new UintN64(0), minRequired: new UintN64(0) }).copy();
    box_get
    assert // Box must have value
    frame_dig -1
    intc_2 // 10
    <
    assert // Index access is out of bounds
    frame_dig -1
    intc_3 // 16
    *
    pushbytes 0x00000000000000000000000000000000
    replace3
    // smart_contracts/flux_gate/flux-gate.algo.ts:27
    // flux_tiers = Box<StaticArray<FluxTier, 10>>({ key: "ft" });
    bytec_0 // "ft"
    // smart_contracts/flux_gate/flux-gate.algo.ts:59
    // this.flux_tiers.value[tierNumber] = new FluxTier({ tierNumber: new UintN64(0), minRequired: new UintN64(0) }).copy();
    swap
    box_put
    // smart_contracts/flux_gate/flux-gate.algo.ts:29
    // current_num_tiers = GlobalState<uint64>();
    intc_1 // 0
    bytec_1 // "current_num_tiers"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/flux_gate/flux-gate.algo.ts:60
    // this.current_num_tiers.value -= 1;
    intc_0 // 1
    -
    // smart_contracts/flux_gate/flux-gate.algo.ts:29
    // current_num_tiers = GlobalState<uint64>();
    bytec_1 // "current_num_tiers"
    // smart_contracts/flux_gate/flux-gate.algo.ts:60
    // this.current_num_tiers.value -= 1;
    swap
    app_global_put
    retsub


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.setUserTier(user: bytes, tier: uint64) -> void:
setUserTier:
    // smart_contracts/flux_gate/flux-gate.algo.ts:63-64
    // @abimethod({ allowActions: "NoOp" })
    // public setUserTier(user: Address, tier: uint64): void {
    proto 2 0
    // smart_contracts/flux_gate/flux-gate.algo.ts:69
    // const record = new FluxRecord({ tier: new UintN64(tier) });
    frame_dig -1
    itob
    // smart_contracts/flux_gate/flux-gate.algo.ts:25
    // flux_records = BoxMap<FluxRecordKey, FluxRecord>({ keyPrefix: "flux_record" });
    bytec_3 // "flux_record"
    frame_dig -2
    concat
    // smart_contracts/flux_gate/flux-gate.algo.ts:70
    // this.flux_records(recordKey).value = record.copy();
    swap
    box_put
    retsub


// smart_contracts/flux_gate/flux-gate.algo.ts::FluxGate.getUserTier(user: bytes) -> bytes:
getUserTier:
    // smart_contracts/flux_gate/flux-gate.algo.ts:73-74
    // @abimethod({ allowActions: "NoOp" })
    // public getUserTier(user: Address): UintN64 {
    proto 1 1
    // smart_contracts/flux_gate/flux-gate.algo.ts:25
    // flux_records = BoxMap<FluxRecordKey, FluxRecord>({ keyPrefix: "flux_record" });
    bytec_3 // "flux_record"
    frame_dig -1
    concat
    dup
    // smart_contracts/flux_gate/flux-gate.algo.ts:76
    // if (this.flux_records(recordKey).exists) {
    box_len
    bury 1
    bz getUserTier_else_body@2
    // smart_contracts/flux_gate/flux-gate.algo.ts:77
    // const record = this.flux_records(recordKey).value.copy();
    box_get
    assert // Box must have value
    // smart_contracts/flux_gate/flux-gate.algo.ts:78
    // return record.tier;
    extract 0 8 // on error: Index access is out of bounds
    retsub

getUserTier_else_body@2:
    // smart_contracts/flux_gate/flux-gate.algo.ts:81
    // const newRecord = new FluxRecord({ tier: new UintN64(0) }).copy();
    bytec 4 // 0x0000000000000000
    // smart_contracts/flux_gate/flux-gate.algo.ts:82
    // this.flux_records(recordKey).value = newRecord.copy();
    box_put
    // smart_contracts/flux_gate/flux-gate.algo.ts:83
    // return newRecord.tier;
    bytec 4 // 0x0000000000000000
    retsub
